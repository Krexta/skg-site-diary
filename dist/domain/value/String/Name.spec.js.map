{"version":3,"sources":["../../../../src/domain/value/String/Name.spec.ts"],"sourcesContent":["import fc from 'fast-check';\nimport { describe, expect, it } from 'vitest';\n\nimport { MAX_FILE_NAME_LENGTH } from './BaseString';\nimport { FileName } from './Name';\n\ndescribe('Name', () => {\n  describe('FileName', () => {\n    it('should return FileName when input is valid', () => {\n      fc.assert(\n        fc.property(\n          fc\n            .string({ minLength: 1, maxLength: MAX_FILE_NAME_LENGTH })\n            .map((val) => val.trim())\n            .filter((val) => val.length >= 1),\n          (name) => {\n            const value = FileName.from(name);\n            expect(value).toBeInstanceOf(FileName);\n            expect(value.value).toEqual(name);\n          },\n        ),\n      );\n    });\n    it('should throw an error when input is empty', () => {\n      fc.assert(\n        fc.property(fc.constantFrom('', ' ', '  '), (name) => {\n          expect(() => FileName.from(name)).toThrow(\n            'FileName must be not empty',\n          );\n        }),\n      );\n    });\n    it('should throw an error when input is too long', () => {\n      fc.assert(\n        fc.property(\n          fc\n            .string({ minLength: MAX_FILE_NAME_LENGTH + 1 })\n            .map((val) => val.trim())\n            .filter((val) => val.length > MAX_FILE_NAME_LENGTH),\n          (name) => {\n            expect(() => FileName.from(name)).toThrow(\n              `FileName has maximum length of ${MAX_FILE_NAME_LENGTH}`,\n            );\n          },\n        ),\n      );\n    });\n    describe('equals', () => {\n      it('should return true when compare two FileName has same value', () => {\n        fc.assert(\n          fc.property(\n            fc\n              .string({ minLength: 1, maxLength: MAX_FILE_NAME_LENGTH })\n              .map((val) => val.trim())\n              .filter((val) => val.length >= 1),\n            (name) => {\n              const value1 = FileName.from(name);\n              const value2 = FileName.from(name);\n              expect(value1).toBeInstanceOf(FileName);\n              expect(value2).toBeInstanceOf(FileName);\n              expect(value1.value).toEqual(name);\n              expect(value2.value).toEqual(name);\n              expect(value1.equals(value2)).toBe(true);\n            },\n          ),\n        );\n      });\n      it('should return true when compare two FileName has difference value', () => {\n        fc.assert(\n          fc.property(\n            fc\n              .record({\n                name1: fc\n                  .string({ minLength: 1, maxLength: MAX_FILE_NAME_LENGTH })\n                  .map((val) => val.trim())\n                  .filter((val) => val.length >= 1),\n                name2: fc\n                  .string({ minLength: 1, maxLength: MAX_FILE_NAME_LENGTH })\n                  .map((val) => val.trim())\n                  .filter((val) => val.length >= 1),\n              })\n              .filter(({ name1, name2 }) => name1 !== name2),\n            ({ name1, name2 }) => {\n              const value1 = FileName.from(name1);\n              const value2 = FileName.from(name2);\n              expect(value1).toBeInstanceOf(FileName);\n              expect(value2).toBeInstanceOf(FileName);\n              expect(value1.value).toEqual(name1);\n              expect(value2.value).toEqual(name2);\n              expect(value1.equals(value2)).toBe(false);\n            },\n          ),\n        );\n      });\n    });\n  });\n});\n"],"names":["fc","describe","expect","it","MAX_FILE_NAME_LENGTH","FileName","assert","property","string","minLength","maxLength","map","val","trim","filter","length","name","value","from","toBeInstanceOf","toEqual","constantFrom","toThrow","value1","value2","equals","toBe","record","name1","name2"],"mappings":"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"}